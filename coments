Коментар 1. Базова адреса = 1000, якщо розмір елемента 4 байти - тоді адреса елементу
А[0] = 1000, А[2] = 1008, A[4] = 1016, тому що розмір елемента 4 байти, а базова адреса = 1000, і с кожним елементом, його адреса збільшується на 4, тобто А[1] = 1004, A[2] = 1008, A[3] = 1012, A[4] = 1016 і так далі...

Коментар 2. Якщо ми знаємо, що кожен елемент займає 4 байти, то ми розуміємо, що для 50 елементів - треба 200 байт памяті, для 500 елементів треба 2000 байт памяті, а для 1 000 000 елементів потрібно 4 000 000 байт памяті.

Коментар 3. Алгоритм А має складність О(1) тому що ми знаходимо перший елемент масиву, з першого разу натрапляючи
на нього, ми починаємо проходитись по масиву з самого початку, і тому одразу натрапляємо на перший елемент, а ось алгоритм В має складність O(n), тому що
в алгоритмі В щоб обчислити суму усіх елементів масиву, потрібно пройтися по кожному елементу в масиві і додати його до попереднього елементу цього масива.

Коментар 5. Перша операція має складність О(n) тому що метод push вставляє новий елемент у кінець масиву, тобто усі інші 
елементи потрібно зсунути, щоб вставити у кінець масиву новий елемент, а друга операція має складність О(1), тому що метод unshift навпаки вставляє елемент на початок масиву, тобто там нічого зсунути не доведеться. 

Коментар 6. 1) O(1) тому що наш алгоритм вже має фіксовану кількість змінних, пам'ять використовується рівномірно, і наш алгоритм не створює нових змінних
2) O(n) тому що кожен рекурсивний виклик створює новий контекст виконання, який зберігається у стеку викликів, та якщо глибина рекурсії становить n, у пам’яті 
одночасно знаходяться n активних викликів функції.  
3) O(n) Ми просто ідентично копіюємо масив, і виходить, що ми ідентично збільшуємо використання пам'яті на стільки, скільки займає початковий перший масив.

